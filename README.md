# 1.锁的底层实现
 java 虚拟机中的同步(Synchronization)基于进入和退出管理(Monitor)对象实现。同步方法，并不是由 monitor enter 和 monitor exit 指令来实现同步的，而是由方法调用指令取运行时常量池中方法的 ACC_SYNCHRONIZED 标记来隐式实现的。
 
## 1.1 对象内存简图
![对象内存简图](https://i.loli.net/2019/07/11/5d26a6c5466ad58228.png "对象内存简图")

  对象头：存储对象的hashCode、锁信息或分代年龄或GC标记，类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类想实例等信息。
  
  实例变量：存放类属性数据信息，包括父类的属性信息。
  
  填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。
  
  当在对象上加锁时，数据是记录在对象头中。当执行synchronize同步方法或同步代码块时，会在对象中记录锁标记，锁标记指向的是monitor对象(也称为管程或监视器锁)的起始地址。每个对象都存在着一个monitor与之关联，对象与其monitor之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个monitor被某个线程持有后，他便处于锁定状态。
  
  在Java虚拟机(HotSpot)中,monitor是有ObjectMonitor实现的。
  
  ObjectMonitor中有两个队列_WaitSet和_EntryList,以及_Owner标记。其中_WaitSet是用于管理等待队列(wait方法)线程的，_Owner标记用于记录当前线程。
  
  线程状态图如下：
  
![对象内存简图](https://i.loli.net/2019/07/11/5d26ac5209ed875137.png "对象内存简图")

  当多线程并发访问**同一个同步代码**时，首先会进入_EntryList,当线程获取锁标记后，monitor中的_Owner记录此线程，并在monitor中的计数器执行递增计算（+1）代表锁定，其他线程在_EntryList中继续阻塞。诺执行线程调用wait方法，则monitor中的计数器执行赋值为0，并将_Owner标记赋值为null，代表放弃锁，执行线程进入_WaitSet中阻塞；诺执行线程调用notify/notifyAll方法，_WaitSet中的线程被唤醒，进入_EntryList中阻塞，等待获取锁标记。诺执行线程的同步代码执行结束，同样会释放锁标记，monitor中的_Owner标记赋值为null，且计数器赋值为0。

## 1.2锁的种类
  Java中锁的种类大致分为偏向锁，自旋锁，轻量级锁，重量级锁。
  锁的使用方式为：先提供偏向锁，如果不满足的时候，升级为轻量级锁，再不满足，升级为重量级锁。自旋锁是一个过渡的锁状态，不是一种实际的锁类型。
  锁只能升级，不能降级。
### 1.2.1 重量级锁
  上述1.1叙述就是重量级锁。
### 1.2.2 偏向锁
  是一种编译解释锁。如果代码中不可能出现多线程并发挣夺同一个锁的时候，JVM编译代码，解释执行的时候，会自动的放弃同步信息。消除synchronized的同步代码结果。使用锁标记的形式记录锁状态。在Monitor中有变量ACC_SYNCHRONIZED。当变量值使用的时候，代表偏向锁锁定。可以避免锁的争抢和锁池状态的维护，提高效率。
### 1.2.3 轻量级锁
  过渡锁，当偏向锁不满足，也就是有多线程并发访问，锁定同一个对象的时候，先提升为轻量级锁。也是使用标记ACC_SYNCHRONIZED标记记录未获取到锁信息的线程。就是只有两个线程争抢锁标记的时候，优先使用轻量级锁。两个线程也可能出现重量锁。
### 1.2.4 自旋锁
  是一个过渡锁，是偏向锁和轻量级锁的过渡。
  当获取锁的过程，未获取到，为了提高效率，JVM自动执行诺干次空循环，再次申请锁，而不是进入阻塞状态的情况。称为自旋锁。自旋锁提高效率就是避免线程状态的变更。
# 2.volatile 关键字
  变量的线程可见性。在cpu计算过程中，会将计算过程需要的数据加载到CPU计算缓存中，CPU计算中断时，有可能刷新缓存，重新读取内存中的数据。在线程运行的过程中，如果某变量被其他线程修改，可能造成数据不一致的情况，从而导致结果错误。而volatile修饰的变量是线程可见的，当JVM解析volatile修饰的变量时，会通知CPU，在计算过程中，每次使用变量参与计算时，都会检查内存中的数据是否发生变化，而不是一直使用CPU缓存中的数据，可以计算结果的正确。
  volatile只是通知底层计算时，cpu检查内存数据，而不是让一个变量在他、多个线程中同步。
# 3.jvm结构

![运行时数据区](https://i.loli.net/2019/07/12/5d27e4f37115522371.png "运行时数据区")

### 3.1jvm堆内存构图及分代
#### 3.1.1 Java虚拟机——jvm内存分代策略
   Java虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代和永久代（对HotSpot虚拟机而言），这就是JVM的内存分代策略。
##### 为什么要分代？
   堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收最频繁的一块区域，我们程序所有的对象实例都存放在堆内存中。给堆内存分代是为了提高对象内存分配和垃圾回收的效率。如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾收集，而每次回收都要遍历所有的对象，遍历这些对象所花费的时间代价是巨大的，会严重影响我们的GC效率。
   有了内存分代，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对象存放咋老年代中，静态属性、类信息等存放在永生代中，新生代中的对象存活时间短，只需要在新生代区域中频繁进行GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收，永久代回收效率太差，一般不进行垃圾回收，还可以根据不同年代的特点采用适合的垃圾收集算法。分代收集大大提升了收集效率，这些都是内存分代带来的好处。
##### 内存分代划分
   Java虚拟机将堆内存划分为新生代、老年代和永久代，永久代是HotSpot虚拟机特有的概念，他采用永久代的方法来实现方法区，其他的虚拟机没有实现这一概念，而且HotSpot也有取消永久代的趋势，在JDK1.7中HotSpot已经开始了“去永久代”，把原本放在永久代的字符串常量池移出。永久代主要存放常量、类信息、静态变量等数据，与垃圾回收关系不大，新生代和老年代是垃圾回收的主要区域。内存分代示意图如下：
   
   ![内存分代图](https://i.loli.net/2019/07/12/5d27e7ed81d6f18842.png "内存分代图")
#### 3.1.2 新生代（Young Generrationn）
   新生成的对象优先存放在新生代中，常规应用进行一次垃圾收集一般可以回收80%-85%的空间，回收率很高。
   HotSpot将新生代划分为三块，一块较大的Eden空间和两块较小的Survivor空间，默认比例为8:1:1.划分的目的是因为HotSpot采用复制算法来回收新生代，设置这个比例是为了充分利用内存空间，减少浪费。新生代的对象在Eden区分配（大对象除外，大对象直接进入老年代），当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。GC开始时，对象只会存在于Eden区和From Survivor区，To Survivor区时空的（作为保留区域）。GC进行时，Eden区中所有存活的对象都都会被复制到To Survivor区，而在From Survivro区中，仍然存活的对象会根据它们的年龄值决定去向，年龄值到达年龄阀值（默认为15，新生代的对象每熬过一轮垃圾回收，年龄值就加一，GC分代年龄存储在对象的header中）的对象会被移动到老年代中，没有到达阀值的对象会被复制到To Survivor区。接着清空Eden区和From Survivor区，新生代中存活的对象都在To Survivor区。接着，From Survivor区和To Survivor区会交换它们的角色，也就是新的To Survivor区就是上次GC清空的From Survivor区，新的From Survivor区就是上次GC的To Survivor区，不管怎么样都会保证To Survivor区在一轮GC后是空的。GC时当To Survivor区没有足够的内存空间存放上一次新生代收集下来的存活对象时，需要依赖老年代进行分配担保，将这些对象存放在老年代中。
#### 3.1.3 老年代（Old Generrationn）
  在新生代中经历了多次（具体看虚拟机配置的阀值）GC后仍然存活下来的对象会进行入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行GC的频率相对而言较低，而且回收的速度也比较慢。
#### 3.1.4 永久代（Permanent Generationn）
  永久代存储类信息，常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，Java虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。

