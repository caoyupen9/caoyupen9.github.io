# 1.锁的底层实现
 java 虚拟机中的同步(Synchronization)基于进入和退出管理(Monitor)对象实现。同步方法，并不是由 monitor enter 和 monitor exit 指令来实现同步的，而是由方法调用指令取运行时常量池中方法的 ACC_SYNCHRONIZED 标记来隐式实现的。
 
## 1.1 对象内存简图
![对象内存简图](https://i.loli.net/2019/07/11/5d26a6c5466ad58228.png "对象内存简图")

  对象头：存储对象的hashCode、锁信息或分代年龄或GC标记，类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类想实例等信息。
  
  实例变量：存放类属性数据信息，包括父类的属性信息。
  
  填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。
  
  当在对象上加锁时，数据是记录在对象头中。当执行synchronize同步方法或同步代码块时，会在对象中记录锁标记，锁标记指向的是monitor对象(也称为管程或监视器锁)的起始地址。每个对象都存在着一个monitor与之关联，对象与其monitor之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个monitor被某个线程持有后，他便处于锁定状态。
  
  在Java虚拟机(HotSpot)中,monitor是有ObjectMonitor实现的。
  
  ObjectMonitor中有两个队列_WaitSet和_EntryList,以及_Owner标记。其中_WaitSet是用于管理等待队列(wait方法)线程的，_Owner标记用于记录当前线程。
  
  线程状态图如下：
  
![对象内存简图](https://i.loli.net/2019/07/11/5d26ac5209ed875137.png "对象内存简图")

  当多线程并发访问**同一个同步代码**时，首先会进入_EntryList,当线程获取锁标记后，monitor中的_Owner记录此线程，并在monitor中的计数器执行递增计算（+1）代表锁定，其他线程在_EntryList中继续阻塞。诺执行线程调用wait方法，则monitor中的计数器执行赋值为0，并将_Owner标记赋值为null，代表放弃锁，执行线程进入_WaitSet中阻塞；诺执行线程调用notify/notifyAll方法，_WaitSet中的线程被唤醒，进入_EntryList中阻塞，等待获取锁标记。诺执行线程的同步代码执行结束，同样会释放锁标记，monitor中的_Owner标记赋值为null，且计数器赋值为0。

## 1.2锁的种类
  Java中锁的种类大致分为偏向锁，自旋锁，轻量级锁，重量级锁。
  锁的使用方式为：先提供偏向锁，如果不满足的时候，升级为轻量级锁，再不满足，升级为重量级锁。自旋锁是一个过渡的锁状态，不是一种实际的锁类型。
  锁只能升级，不能降级。
### 1.2.1 重量级锁
  上述1.1叙述就是重量级锁。
### 1.2.2 偏向锁
  是一种编译解释锁。如果代码中不可能出现多线程并发挣夺同一个锁的时候，JVM编译代码，解释执行的时候，会自动的放弃同步信息。消除synchronized的同步代码结果。使用锁标记的形式记录锁状态。在Monitor中有变量ACC_SYNCHRONIZED。当变量值使用的时候，代表偏向锁锁定。可以避免锁的争抢和锁池状态的维护，提高效率。
### 1.2.3 轻量级锁
过渡锁，当偏向锁不满足，也就是有多线程并发访问，锁定同一个对象的时候，先提升为轻量级锁。也是使用标记ACC_SYNCHRONIZED标记记录未获取到锁信息的线程。就是只有两个线程争抢锁标记的时候，优先使用轻量级锁。两个线程也可能出现重量锁。
# 2.volatile 关键字
  变量的线程可见性。在cpu计算过程中，会将计算过程需要的数据加载到CPU计算缓存中，CPU计算中断时，有可能刷新缓存，重新读取内存中的数据。在线程运行的过程中，如果某变量被其他线程修改，可能造成数据不一致的情况，从而导致结果错误。而volatile修饰的变量是线程可见的，当JVM解析volatile修饰的变量时，会通知CPU，在计算过程中，每次使用变量参与计算时，都会检查内存中的数据是否发生变化，而不是一直使用CPU缓存中的数据，可以计算结果的正确。
  volatile只是通知底层计算时，cpu检查内存数据，而不是让一个变量在他、多个线程中同步。
